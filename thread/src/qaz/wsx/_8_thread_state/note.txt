线程对象的状态存放在Thread类的内部类(State)中:
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}

1:新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.
    新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.
    Thread t = new Thread();//此时t就属于新建状态
    当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态.
    线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException.
2:可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态。
    就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).
    运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行.
3:阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.
    此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.
    阻塞状态只能先进入就绪状态,不能直接进入运行状态.
    阻塞状态的两种情况:
    1):当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.
    2):当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态.
4:等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,
    1):当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中.
5:计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法)
    1):当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.
    2):当前线程执行了sleep(long time)方法.
6:终止状态(terminated):通常称为死亡状态，表示线程终止.
    1):正常执行完run方法而退出(正常死亡).
    2):遇到异常而退出(出现异常之后,程序就会中断)(意外死亡).
    *线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).
