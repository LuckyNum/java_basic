1.线程休眠:让执行的线程暂停一段时间，进入计时等待状态。
    方法:static void sleep(long millis)
    调用sleep后，当前线程放弃CPU,在指定时间段之内，sleep所在线程不会获得执行的机会。
    此状态下的线程不会释放同步锁/同步监听器.
    该方法更多的用于模拟网络延迟,让多线程并发访问同一个资源的错误效果更明显.
2.联合线程:
    线程的join方法表示一个线程等待另一个线程完成后才执行。join方法被调用之后，线程对象处于阻塞状态。
    有人也把这种方式称为联合线程，就是说把当前线程和当前线程所在的线程联合成一个线程。
               joinThread.start()
                 +----------+
      +---------->joinThread+--------+
+----------+     +----------+     +--v-------+  +----------+
|mainThread|                      |joinThread+-->mainThread|
+----------+     +----------+     +--^-------+  +----------+
      +---------->mainThread+--------+
                 +----------+     joinThread.join()

3.后台线程：在后台运行的线程，其目的是为其他线程提供服务，也称为“守护线程"。JVM的垃圾回收线程就是典型的后台线程。
    特点：若所有的前台线程都死亡，后台线程自动死亡,前台线程没有结束,后台线程是不会结束的。
    测试线程对象是否为后台线程：使用thread.isDaemon()。
    前台线程创建的线程默认是前台线程,可以通过setDaenon(true)方法设置为后台线程,并且当且仅当后台线程创建的新线程时，新线程是后台线程。
    设置后台线程：thread.setDaemon(true),该方法必须在start方法调用前，否则出现IllegalThreadStateException异常

4.线程优先级:
    每个线程都有优先级，优先级的高低只和线程获得执行机会的次数多少有关,并非线程优先级越高的就一定先执行，哪个线程的先运行取决于CPU的调度。
    MAX_PRIORITY=10,最高优先级
    MIN_PRIORITY=1,最低优先级
    NORM_PRIORITY=5,默认优先级
    -----------------------
    int getPriority() :返回线程的优先级。
    void setPriority(int newPriority) : 更改线程的优先级。
    -----------------------
    每个线程都有默认优先级,主线程默认优先级为5,如果A线程创建了B线程,那么B线程和A线程具有相同优先级.
    *注意:不同的操作系统支持的线程优先级不同的,建议使用上述三个优先级,不要自定义.

5.线程礼让:
    yield方法：表示当前线程对象提示调度器<自己愿意让出CPU资源，但是调度器可以自由的忽略该提示。>
    调用该方法之后，线程对象进入就绪状态，所以完全有可能：某个线程调用了yield()之后，线程调度器又把它调度出来重新执行。
    从Java7提供的文档上可以清楚的看出，开发中很少会使用到该方法，该方法主要用于调试或测试，它可能有助于因多线程竞争条件下的错误重现现象。
    -----------------------------------------
    sleep方法和yield方法的区别:
      1):都能使当前处于运行状态的线程放弃CPU,把运行的机会给其他线程.
      2):sleep方法会给其他线程运行机会,但是不考虑其他线程的优先级,yield方法只会给相同优先级或者更高优先级的线程运行的机会.
      3):调用sleep方法后,线程进入计时等待状态,调用yield方法后,线程进入就绪状态.

